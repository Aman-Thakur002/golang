/*
=============================================================================
                        üåê GO HTTP SERVER TUTORIAL
=============================================================================

üìö CORE CONCEPT:
HTTP servers in Go handle incoming requests and send responses. The net/http
package provides everything needed to build robust web servers and APIs.

üîë KEY FEATURES:
‚Ä¢ Simple HTTP server setup
‚Ä¢ Route handling and multiplexing
‚Ä¢ Middleware support
‚Ä¢ JSON API endpoints
‚Ä¢ Static file serving

üí° REAL-WORLD ANALOGY:
HTTP Server = Restaurant
- Routes = Menu items (what you can order)
- Handlers = Kitchen staff (who prepares your order)
- Middleware = Waiters (who process requests before/after)
- Response = Your prepared meal

üéØ WHY LEARN HTTP SERVERS?
‚Ä¢ Build REST APIs and web services
‚Ä¢ Create microservices
‚Ä¢ Serve web applications
‚Ä¢ Handle real-time communication

=============================================================================
*/

package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"
)

// üìä DATA STRUCTURES: For API responses
type User struct {
	ID    int    `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
}

type APIResponse struct {
	Success bool        `json:"success"`
	Data    interface{} `json:"data,omitempty"`
	Message string      `json:"message,omitempty"`
	Error   string      `json:"error,omitempty"`
}

// üíæ IN-MEMORY DATA STORE: Simple storage for demo
var users = []User{
	{ID: 1, Name: "John Doe", Email: "john@example.com"},
	{ID: 2, Name: "Jane Smith", Email: "jane@example.com"},
	{ID: 3, Name: "Bob Johnson", Email: "bob@example.com"},
}

var nextUserID = 4

// üéØ BASIC HANDLERS: Simple request handlers
func homeHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "üè† Welcome to Go HTTP Server!\n")
	fmt.Fprintf(w, "üìÖ Current time: %s\n", time.Now().Format(time.RFC3339))
	fmt.Fprintf(w, "üîó Available endpoints:\n")
	fmt.Fprintf(w, "  GET  /users     - List all users\n")
	fmt.Fprintf(w, "  GET  /users/1   - Get user by ID\n")
	fmt.Fprintf(w, "  POST /users     - Create new user\n")
	fmt.Fprintf(w, "  PUT  /users/1   - Update user\n")
	fmt.Fprintf(w, "  DELETE /users/1 - Delete user\n")
}

func aboutHandler(w http.ResponseWriter, r *http.Request) {
	response := APIResponse{
		Success: true,
		Data: map[string]string{
			"name":        "Go HTTP Server Tutorial",
			"version":     "1.0.0",
			"description": "Learning HTTP server development in Go",
		},
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// üë• USER HANDLERS: CRUD operations for users
func usersHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	
	switch r.Method {
	case http.MethodGet:
		handleGetUsers(w, r)
	case http.MethodPost:
		handleCreateUser(w, r)
	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

func userHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	
	// Extract user ID from URL path
	path := strings.TrimPrefix(r.URL.Path, "/users/")
	userID, err := strconv.Atoi(path)
	if err != nil {
		response := APIResponse{
			Success: false,
			Error:   "Invalid user ID",
		}
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(response)
		return
	}
	
	switch r.Method {
	case http.MethodGet:
		handleGetUser(w, r, userID)
	case http.MethodPut:
		handleUpdateUser(w, r, userID)
	case http.MethodDelete:
		handleDeleteUser(w, r, userID)
	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

func handleGetUsers(w http.ResponseWriter, r *http.Request) {
	response := APIResponse{
		Success: true,
		Data:    users,
		Message: fmt.Sprintf("Found %d users", len(users)),
	}
	json.NewEncoder(w).Encode(response)
}

func handleGetUser(w http.ResponseWriter, r *http.Request, userID int) {
	for _, user := range users {
		if user.ID == userID {
			response := APIResponse{
				Success: true,
				Data:    user,
			}
			json.NewEncoder(w).Encode(response)
			return
		}
	}
	
	response := APIResponse{
		Success: false,
		Error:   "User not found",
	}
	w.WriteHeader(http.StatusNotFound)
	json.NewEncoder(w).Encode(response)
}

func handleCreateUser(w http.ResponseWriter, r *http.Request) {
	var newUser User
	err := json.NewDecoder(r.Body).Decode(&newUser)
	if err != nil {
		response := APIResponse{
			Success: false,
			Error:   "Invalid JSON data",
		}
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(response)
		return
	}
	
	// Assign new ID
	newUser.ID = nextUserID
	nextUserID++
	
	// Add to users slice
	users = append(users, newUser)
	
	response := APIResponse{
		Success: true,
		Data:    newUser,
		Message: "User created successfully",
	}
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(response)
}

func handleUpdateUser(w http.ResponseWriter, r *http.Request, userID int) {
	var updatedUser User
	err := json.NewDecoder(r.Body).Decode(&updatedUser)
	if err != nil {
		response := APIResponse{
			Success: false,
			Error:   "Invalid JSON data",
		}
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(response)
		return
	}
	
	// Find and update user
	for i, user := range users {
		if user.ID == userID {
			updatedUser.ID = userID // Preserve ID
			users[i] = updatedUser
			
			response := APIResponse{
				Success: true,
				Data:    updatedUser,
				Message: "User updated successfully",
			}
			json.NewEncoder(w).Encode(response)
			return
		}
	}
	
	response := APIResponse{
		Success: false,
		Error:   "User not found",
	}
	w.WriteHeader(http.StatusNotFound)
	json.NewEncoder(w).Encode(response)
}

func handleDeleteUser(w http.ResponseWriter, r *http.Request, userID int) {
	for i, user := range users {
		if user.ID == userID {
			// Remove user from slice
			users = append(users[:i], users[i+1:]...)
			
			response := APIResponse{
				Success: true,
				Message: "User deleted successfully",
			}
			json.NewEncoder(w).Encode(response)
			return
		}
	}
	
	response := APIResponse{
		Success: false,
		Error:   "User not found",
	}
	w.WriteHeader(http.StatusNotFound)
	json.NewEncoder(w).Encode(response)
}

// üîß MIDDLEWARE: Functions that wrap handlers
func loggingMiddleware(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		
		// Call the next handler
		next(w, r)
		
		// Log the request
		duration := time.Since(start)
		log.Printf("üìù %s %s - %v", r.Method, r.URL.Path, duration)
	}
}

func corsMiddleware(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Set CORS headers
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
		
		// Handle preflight requests
		if r.Method == http.MethodOptions {
			w.WriteHeader(http.StatusOK)
			return
		}
		
		// Call the next handler
		next(w, r)
	}
}

func authMiddleware(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Simple API key authentication (for demo)
		apiKey := r.Header.Get("X-API-Key")
		if apiKey != "demo-api-key" && r.URL.Path != "/" && r.URL.Path != "/about" {
			response := APIResponse{
				Success: false,
				Error:   "Invalid or missing API key",
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusUnauthorized)
			json.NewEncoder(w).Encode(response)
			return
		}
		
		// Call the next handler
		next(w, r)
	}
}

// üéØ CUSTOM MULTIPLEXER: Route handling
func setupRoutes() *http.ServeMux {
	mux := http.NewServeMux()
	
	// Apply middleware to handlers
	mux.HandleFunc("/", corsMiddleware(loggingMiddleware(authMiddleware(homeHandler))))
	mux.HandleFunc("/about", corsMiddleware(loggingMiddleware(aboutHandler)))
	mux.HandleFunc("/users", corsMiddleware(loggingMiddleware(authMiddleware(usersHandler))))
	
	// Handle user-specific routes
	mux.HandleFunc("/users/", corsMiddleware(loggingMiddleware(authMiddleware(userHandler))))
	
	return mux
}

func main() {
	fmt.Println("üåê HTTP SERVER TUTORIAL")
	fmt.Println("=======================")

	// üéØ DEMO: Complete HTTP Server
	fmt.Println("\nüéØ Starting HTTP Server")
	fmt.Println("=======================")

	// Setup routes
	mux := setupRoutes()
	
	// Create server with custom configuration
	server := &http.Server{
		Addr:         ":8080",
		Handler:      mux,
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	fmt.Println("üöÄ Server starting on http://localhost:8080")
	fmt.Println("üìã Available endpoints:")
	fmt.Println("  GET    http://localhost:8080/")
	fmt.Println("  GET    http://localhost:8080/about")
	fmt.Println("  GET    http://localhost:8080/users")
	fmt.Println("  POST   http://localhost:8080/users")
	fmt.Println("  GET    http://localhost:8080/users/1")
	fmt.Println("  PUT    http://localhost:8080/users/1")
	fmt.Println("  DELETE http://localhost:8080/users/1")
	fmt.Println()
	fmt.Println("üîë API Key required for protected endpoints: X-API-Key: demo-api-key")
	fmt.Println()
	fmt.Println("üìù Example curl commands:")
	fmt.Println(`  curl http://localhost:8080/`)
	fmt.Println(`  curl -H "X-API-Key: demo-api-key" http://localhost:8080/users`)
	fmt.Println(`  curl -X POST -H "X-API-Key: demo-api-key" -H "Content-Type: application/json" \`)
	fmt.Println(`       -d '{"name":"New User","email":"new@example.com"}' \`)
	fmt.Println(`       http://localhost:8080/users`)
	fmt.Println()
	fmt.Println("‚èπÔ∏è  Press Ctrl+C to stop the server")

	// Start server
	log.Fatal(server.ListenAndServe())
}

/*
=============================================================================
                              üìù LEARNING NOTES
=============================================================================

üåê HTTP SERVER BASICS:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ // Simple server                                                        ‚îÇ
‚îÇ http.HandleFunc("/", handler)                                           ‚îÇ
‚îÇ log.Fatal(http.ListenAndServe(":8080", nil))                            ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ // Custom server                                                        ‚îÇ
‚îÇ server := &http.Server{                                                 ‚îÇ
‚îÇ     Addr:    ":8080",                                                   ‚îÇ
‚îÇ     Handler: mux,                                                       ‚îÇ
‚îÇ     ReadTimeout:  15 * time.Second,                                     ‚îÇ
‚îÇ     WriteTimeout: 15 * time.Second,                                     ‚îÇ
‚îÇ }                                                                       ‚îÇ
‚îÇ log.Fatal(server.ListenAndServe())                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üéØ HANDLER PATTERNS:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ // Function handler                                                     ‚îÇ
‚îÇ func handler(w http.ResponseWriter, r *http.Request) {                   ‚îÇ
‚îÇ     fmt.Fprintf(w, "Hello, World!")                                     ‚îÇ
‚îÇ }                                                                       ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ // Method-based routing                                                 ‚îÇ
‚îÇ func apiHandler(w http.ResponseWriter, r *http.Request) {               ‚îÇ
‚îÇ     switch r.Method {                                                   ‚îÇ
‚îÇ     case http.MethodGet:                                                ‚îÇ
‚îÇ         // Handle GET                                                   ‚îÇ
‚îÇ     case http.MethodPost:                                               ‚îÇ
‚îÇ         // Handle POST                                                  ‚îÇ
‚îÇ     default:                                                            ‚îÇ
‚îÇ         http.Error(w, "Method not allowed", 405)                        ‚îÇ
‚îÇ     }                                                                   ‚îÇ
‚îÇ }                                                                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üìä HTTP RESPONSE PATTERNS:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ // Plain text response                                                  ‚îÇ
‚îÇ fmt.Fprintf(w, "Hello, World!")                                         ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ // JSON response                                                        ‚îÇ
‚îÇ w.Header().Set("Content-Type", "application/json")                      ‚îÇ
‚îÇ json.NewEncoder(w).Encode(data)                                         ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ // Error response                                                       ‚îÇ
‚îÇ http.Error(w, "Not found", http.StatusNotFound)                         ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ // Custom status code                                                   ‚îÇ
‚îÇ w.WriteHeader(http.StatusCreated)                                       ‚îÇ
‚îÇ json.NewEncoder(w).Encode(response)                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üîß MIDDLEWARE PATTERN:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ func middleware(next http.HandlerFunc) http.HandlerFunc {               ‚îÇ
‚îÇ     return func(w http.ResponseWriter, r *http.Request) {               ‚îÇ
‚îÇ         // Before request processing                                    ‚îÇ
‚îÇ         log.Printf("Request: %s %s", r.Method, r.URL.Path)              ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ         // Call next handler                                            ‚îÇ
‚îÇ         next(w, r)                                                      ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ         // After request processing                                     ‚îÇ
‚îÇ         log.Println("Request completed")                                ‚îÇ
‚îÇ     }                                                                   ‚îÇ
‚îÇ }                                                                       ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ // Usage                                                                ‚îÇ
‚îÇ http.HandleFunc("/api", middleware(apiHandler))                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üóÇÔ∏è ROUTING STRATEGIES:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ // Built-in ServeMux                                                    ‚îÇ
‚îÇ mux := http.NewServeMux()                                               ‚îÇ
‚îÇ mux.HandleFunc("/users", usersHandler)                                  ‚îÇ
‚îÇ mux.HandleFunc("/users/", userHandler) // Trailing slash for subtree    ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ // Pattern matching                                                     ‚îÇ
‚îÇ mux.HandleFunc("/api/v1/", apiV1Handler)                                ‚îÇ
‚îÇ mux.HandleFunc("/static/", http.StripPrefix("/static/",                 ‚îÇ
‚îÇ     http.FileServer(http.Dir("./static/"))))                            ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ // Third-party routers (gorilla/mux, chi, gin)                         ‚îÇ
‚îÇ // r := mux.NewRouter()                                                 ‚îÇ
‚îÇ // r.HandleFunc("/users/{id}", getUserHandler).Methods("GET")           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üìù REQUEST HANDLING:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ // Read request body                                                    ‚îÇ
‚îÇ body, err := io.ReadAll(r.Body)                                         ‚îÇ
‚îÇ defer r.Body.Close()                                                    ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ // Parse JSON                                                           ‚îÇ
‚îÇ var data MyStruct                                                       ‚îÇ
‚îÇ err := json.NewDecoder(r.Body).Decode(&data)                            ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ // Get query parameters                                                 ‚îÇ
‚îÇ id := r.URL.Query().Get("id")                                           ‚îÇ
‚îÇ values := r.URL.Query()["tags"]                                         ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ // Get form values                                                      ‚îÇ
‚îÇ r.ParseForm()                                                           ‚îÇ
‚îÇ name := r.FormValue("name")                                             ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ // Get headers                                                          ‚îÇ
‚îÇ auth := r.Header.Get("Authorization")                                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üö® ERROR HANDLING:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ // Standard error response                                              ‚îÇ
‚îÇ http.Error(w, "Internal Server Error", http.StatusInternalServerError)  ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ // JSON error response                                                  ‚îÇ
‚îÇ type ErrorResponse struct {                                             ‚îÇ
‚îÇ     Error   string `json:"error"`                                       ‚îÇ
‚îÇ     Code    int    `json:"code"`                                        ‚îÇ
‚îÇ     Message string `json:"message"`                                     ‚îÇ
‚îÇ }                                                                       ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ func sendError(w http.ResponseWriter, err string, code int) {            ‚îÇ
‚îÇ     w.Header().Set("Content-Type", "application/json")                  ‚îÇ
‚îÇ     w.WriteHeader(code)                                                 ‚îÇ
‚îÇ     json.NewEncoder(w).Encode(ErrorResponse{                            ‚îÇ
‚îÇ         Error:   err,                                                   ‚îÇ
‚îÇ         Code:    code,                                                  ‚îÇ
‚îÇ         Message: http.StatusText(code),                                 ‚îÇ
‚îÇ     })                                                                  ‚îÇ
‚îÇ }                                                                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üí° BEST PRACTICES:
‚Ä¢ Always set appropriate Content-Type headers
‚Ä¢ Use proper HTTP status codes
‚Ä¢ Implement proper error handling
‚Ä¢ Add request logging and monitoring
‚Ä¢ Use middleware for cross-cutting concerns
‚Ä¢ Set timeouts on your server
‚Ä¢ Validate input data
‚Ä¢ Handle graceful shutdown

üéØ REAL-WORLD PATTERNS:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ // API versioning                                                       ‚îÇ
‚îÇ mux.HandleFunc("/api/v1/users", v1UsersHandler)                         ‚îÇ
‚îÇ mux.HandleFunc("/api/v2/users", v2UsersHandler)                         ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ // Health check endpoint                                                ‚îÇ
‚îÇ mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) { ‚îÇ
‚îÇ     w.WriteHeader(http.StatusOK)                                        ‚îÇ
‚îÇ     fmt.Fprintf(w, "OK")                                                ‚îÇ
‚îÇ })                                                                      ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ // Static file serving                                                  ‚îÇ
‚îÇ fs := http.FileServer(http.Dir("./static/"))                            ‚îÇ
‚îÇ mux.Handle("/static/", http.StripPrefix("/static/", fs))                ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ // Graceful shutdown                                                    ‚îÇ
‚îÇ c := make(chan os.Signal, 1)                                            ‚îÇ
‚îÇ signal.Notify(c, os.Interrupt)                                          ‚îÇ
‚îÇ go func() {                                                             ‚îÇ
‚îÇ     <-c                                                                 ‚îÇ
‚îÇ     ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second) ‚îÇ
‚îÇ     defer cancel()                                                      ‚îÇ
‚îÇ     server.Shutdown(ctx)                                                ‚îÇ
‚îÇ }()                                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚ö° PERFORMANCE TIPS:
‚Ä¢ Use connection pooling
‚Ä¢ Implement proper caching
‚Ä¢ Use compression middleware
‚Ä¢ Set appropriate buffer sizes
‚Ä¢ Consider using reverse proxy (nginx)
‚Ä¢ Monitor memory usage and goroutine leaks
‚Ä¢ Use profiling tools (pprof)

=============================================================================
*/